# Структура репозитория
## [Полезные материалы](https://github.com/DeSauzzz/PCU-SV-upgrade/tree/main/docs)
Здесь лежат материалы, которые помогут быстрее вам вкатиться в основы проектирования на **SystemVerilog**
### [Гайд на Vivado](https://github.com/DeSauzzz/PCU-SV-upgrade/blob/main/docs/vivado_manual.md)
## [Лабораторные работы](https://github.com/Konf/PCU-SV-new/tree/main/Labs)
Здесь лежат лабораторные работы, которые вам необходимо будет выполнить во время изучения данной дисциплины. Всего в курсе будет **девять** лабораторных работ, которые
позволят вам получить бесценный опыт в области проектирования цифровых устройств на языке описания аппаратуры **(SystemVerilog)**
### [Лабораторная работа 1. Введение в язык SystemVerilog. Комбинаторная логика.](https://github.com/Konf/PCU-SV-new/tree/main/Labs/01.%20Comb%20Logic)
В данной лабораторной работе вы научитесь создавать самые простые _цифровые устройства_: элементы **"И"** и **"ИЛИ"**, их комбинации, а в конце - собрать из них полноценные
**мультиплексор** и **дешифратор**. Данные элементы - кирпичики из которых строятся все современные процессоры и радиомодули.
#### Почему начинаем с этого?
Комбинаторная логика — это самый простой для понимания мост между миром радиотехники и миром HDL. Нет никаких тактовых частот, регистров, памяти. Есть входы, есть выходы. 
Подали сигнал на вход — мгновенно получили результат на выходе. Почти как в аналоговой схеме, только с нулями и единицами. 
Вы сразу увидите, как каждая строчка кода превращается в понятную вам принципиальную схему.
### [Лабораторная работа 2. Регистры и счётчики](https://github.com/Konf/PCU-SV-new/tree/main/Labs/02.%20Registers)
В прошлой лабораторной работе создавались исключительно комбинаторные устройства. В этой лабораторной работе вы научитесь проектировать последовательностные цифровые устройства.
Если комбинационная логика — это _мгновенный рефлекс_, то последовательностная логика — это _осознанное поведение_. У устройства появляется память о прошлом. 
Его выход зависит не только от того, что сейчас на входе, но и от того, что было на входе ранее.
#### С чем познакомитесь?
1. **D-триггер (Data Trigger)**: Это простейшая **ячейка памяти**. Он _запоминает_ значение на своем входе в момент тактового импульса и хранит его до следующего импульса. Один такой триггер — это один бит памяти.
2. **Регистр (Register)**: Это группа триггеров, объединенных общим тактовым сигналом. Если триггер — это один _листок бумаги_ для записи, то регистр — это целый _блокнот_. 
   Он может хранить код команды, промежуточный результат вычислений или состояние вашего устройства.
3. **Счётчик (Counter)**: Это регистр, который благодаря добавлению небольшой комбинационной логики, будет увеличивать значение, хранящееся в нем, на единицу каждый такт.
### [Лабораторная работа 3. Язык Tcl](https://github.com/Konf/PCU-SV-new/tree/main/Labs/03.%20tcl)
В данной лабораторной работе вы научитесь управлять проектом с помощью скриптов, что зачастую существенно экономит время при разработке цифровых устройств.
#### Зачем TCL нужен?
Представьте, что вы сделали изменение в коде вашего модуля на SystemVerilog. Чтобы проверить его, вам нужно:
1. Запустить синтез.
2. Запустить симуляцию.
3. Посмотреть отчёты по времени.
4. Посмотреть карту ресурсов.

В графическом интерфейсе вы делаете это мышкой, трятя на это свое драгоценное время. Теперь представьте, что вы итерационно улучшаете схему, и таких циклов нужно сделать 50.
Ручная работа в таком случае становится неоптимальной.

В свою очередь на **TCL** вы можете написать скрипт, который всю рутину выполнит за вас, тем самым ускорив ваш рабочий процесс.
### [Лабораторная работа 4. Динамическая индикация 7-сегментных экранов](https://github.com/Konf/PCU-SV-new/tree/main/Labs/04.%20Dynamic%20HEX)
### [Лабораторная работа 5. Конечные автоматы](https://github.com/Konf/PCU-SV-new/tree/main/Labs/05.%20FSM)
В предыдущих лабораторных работах вы создавали устройства, которые реагировали на входные воздействия более-менее прямолинейно. Комбинационная схема — мгновенно, последовательностная — по такту. 
Но можем ли мы создать цифровое устройство, которое обладает _поведением_? Которое может ждать, принимать решения и последовательно выполнять действия в зависимости от того, что с ним происходит?

**Конечный автомат (Finite State Machine, FSM)** — блок, особенность которого в том, что на различные входные воздействия его реакция также различна.

#### Из чего состоит любой автомат?
1. Набор состояний (States): IDLE_S, WORK_S, DONE_S и т.д. Это те _шаги_, между которыми переключается система.
2. Входные сигналы (Inputs): Кнопки, датчики, флаги от других модулей. Это те сигналы, на основе которых автомат принимает дальнейшее решение.
3. Выходные сигналы (Outputs): Управление моторами, светом, передача данных. Это то, что автомат _делает_ в ответ.
4. Правила переходов (Next state logic): Логика, которая по текущему состоянию и входным сигналам определяет следующее состояние.
5. Функция выходов (Output Logic): Определяет, какие сигналы должны быть установлены в каждом состоянии.

### [Лабораторная работа 6. LUTRAM и BRAM](https://github.com/Konf/PCU-SV-new/tree/main/Labs/06.%20LUTRAM%20BRAM)
Когда мы спускаемся на уровень физической реализации в ПЛИС, оказывается, что _память_ может быть синтезирована по-разному. 
Это специализированный ресурс, и от того, как мы его используем, зависит буквально всё: быстродействие, потребление и эффективность всего устройства.

В данной лабораторной работе вы познакомитесь с LUTRAM и BRAM памятью. Научитесь определять, в каких ситуациях выгодно использовать BRAM память, а в каких LUTRAM память.
#### Почему это разделение существует?
1. **LUTRAM** — это не совсем память, а скорее побочный эффект для LUT. LUT (таблицы поиска) — это основа комбинационной логики ПЛИС. Оказалось, что их можно сконфигурировать и как небольшую RAM. 
Это распределённая память — она _размазана_ по всей матрице ПЛИС. Плюс: несколько портов, асинхронное чтение. Минус: малый объём.
2. **BRAM** — это специализированные блоки внутри ПЛИС. Это не логика, а заранее заложенные в кристалл блоки статической памяти (SRAM). 
Это блочная память. Плюс: огромная плотность (экономия логических ресурсов), предсказуемое время доступа. Минус: ограниченное количество портов, обычно синхронная работа.
### [Лабораторная работа 7. RAM-память и FIFO](https://github.com/Konf/PCU-SV-new/tree/main/Labs/07.%20FIFO)
При использовании **LUTRAM** и **BRAM** без каких-либо видоизменений можно столкнуться со следующими проблемами:

* _Проблема 1_: У вас есть два модуля. Один генерирует данные с переменной скоростью, а другой обрабатывает их, но тоже с переменной скоростью. 
Как их согласовать? Если обработчик не успевает, данные будут теряться.
* _Проблема 2_: Ваш модуль пишет данные в память, а другой — читает из неё. Что произойдёт, если они обратятся к одной и той же ячейке одновременно? Возникнет конфликт, _гонка_, и данные могут быть испорчены.

Решение этих проблем - тема данной лабораторной работы.

#### Часть 1: RAM (Random Access Memory).
Мы возьмём блок BRAM и создадим из него полноценную память с интерфейсом: адрес, данные для записи, данные для чтения, сигналы разрешения записи и чтения.
Ключевой момент: мы должны разработать арбитраж. Это логика, которая решает, кто сейчас имеет право работать с памятью, если запросов несколько. Это основа многопортовой памяти.
#### Часть 2: FIFO (First-In, First-Out).
FIFO — это модификация обычной RAM. Это буфер, организованный по принципу очереди: кто первым пришёл, тот первым и обслужен.
### [Лабораторная работа 8. Контроллер PS/2 для клавиатуры](https://github.com/Konf/PCU-SV-new/tree/main/Labs/08.%20PS2)
### [Лабораторная работа 9. Цифровой звук](https://github.com/Konf/PCU-SV-new/tree/main/Labs/09.%20Audio)
